from datetime import datetime, timedelta
from io import BytesIO
from typing import Optional

import disnake
import sqlalchemy
from derpz_botlib.cog import CogConfiguration, DatabaseConfigurableCog
from disnake.ext import commands
from math_tavern_bot_py.bot import BookBot
from math_tavern_bot_py.plugins.booklist.models import BookInDb
from math_tavern_bot_py.plugins.booklist.upload import (download_book_from_db,
                                                        search_book_in_db)
from math_tavern_bot_py.plugins.booklist.upload_views import UploadView
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession


class BookListPluginConfig(CogConfiguration):
    book_list_channel: Optional[int] = None


class BookListPlugin(DatabaseConfigurableCog[BookListPluginConfig]):
    """
    Cog for managing a book list channel.
    """

    bot: BookBot

    def __init__(self, bot: BookBot):
        super().__init__(bot, BookListPluginConfig)

    @commands.slash_command(name="booklist")
    async def cmd_book_list(self, ctx: disnake.ApplicationCommandInteraction):
        pass

    @cmd_book_list.sub_command(
        name="list", description="Prints out the list of books in the DB"
    )
    async def list_books(self, ctx: disnake.ApplicationCommandInteraction):
        """
        Prints out the list of books in the DB.
        TODO: Add pagination
        TODO: Should really be printing out books in book list instead.
        :param ctx:
        :return:
        """
        # TODO: Logic should be separated
        guild_config = self.config.get(ctx.guild, BookListPluginConfig())
        # TODO: Not guild specific

        async with AsyncSession(self.bot.engine) as sess:
            stmt = sqlalchemy.select(BookInDb).order_by(BookInDb.title)

            # TODO: Do not loop, do pagination instead
            res = await sess.scalars(stmt)
            books = res.fetchall()
            await ctx.send(f"Obtained {len(books)} books from the database")
            for book in books:
                book: BookInDb
                embed = disnake.Embed(title=book.title)
                # TODO: Hardcoded
                embed.set_footer(text="Generated by Math Tavern Bot")
                embed.add_field(name="Author", value=book.author, inline=False)
                embed.add_field(name="ISBN", value=book.isbn, inline=False)
                embed.add_field(name="Subject", value=book.subject, inline=False)
                # TODO: Make this a link
                embed.add_field(name="S3 Key", value=book.s3_key, inline=False)
                await ctx.send(embed=embed)

    @cmd_book_list.sub_command_group()
    async def config(self, ctx: disnake.ApplicationCommandInteraction):
        pass

    @cmd_book_list.sub_command_group()
    async def maintenance(self, ctx: disnake.ApplicationCommandInteraction):
        pass

    @commands.Cog.listener()
    async def on_message(self, message: disnake.Message):
        """Keeps the book list channel clean by deleting any non-bot messages"""
        guild_config = self.get_guild_config(message.guild)
        book_list_channel = guild_config.book_list_channel
        if (
            book_list_channel
            and message.channel.id == book_list_channel
            and message.author != self.bot.user
        ):
            replied = await message.reply("Your message is being vaporized...")
            await message.delete()
            await replied.delete()

    @config.sub_command(description="Sets the book list channel")
    @commands.guild_only()
    async def book_list_channel(
        self,
        ctx: disnake.ApplicationCommandInteraction,
        *,
        channel: disnake.TextChannel = commands.Param(
            description="The channel which will be managed by the book list bot"
        ),
    ):
        """
        Sets the book list channel. Note that the book list channel will be
        managed by the bot. All messages that are not posted by the bot
        will be deleted. After running this, you need to run the
        `sync_books_list` command to re-sync the book list channel.

        Parameters
        ----------
        channel: :class:`disnake.TextChannel`
            The channel which will be managed by the book list bot
        """
        guild_config = self.get_guild_config(ctx.guild)
        guild_config.book_list_channel = channel.id
        await self.save_guild_config(ctx.guild, guild_config)
        await ctx.send(
            f"Setting the book list channel to {channel.mention}. "
            f"Please sync the book list channel now."
        )

    @maintenance.sub_command(description="Re syncs the book list channel")
    @commands.guild_only()
    @commands.has_permissions(manage_messages=True, manage_channels=True)
    async def sync_books_list(self, ctx: disnake.ApplicationCommandInteraction):
        """
        Forces the bot to re-sync the books list. This will delete all the
        messages in the book list channel and re-post all the books in the
        database. Useful if someone accidentally deletes a message in the
        book list channel.
        """
        guild_config = self.get_guild_config(ctx.guild)
        if not guild_config.book_list_channel:
            await ctx.send("Book list channel is not set")
            return
        channel = ctx.guild.get_channel(guild_config.book_list_channel)
        if not channel:
            await ctx.send("Book list channel is not found")
            return
        await ctx.send(
            "Are you sure you want to sync the book list channel? "
            "This will delete all the messages in the book list channel."
        )
        confirm = await ctx.original_response()
        await confirm.add_reaction("\N{WHITE HEAVY CHECK MARK}")
        await confirm.add_reaction("\N{CROSS MARK}")

        is_confirmed = await self.bot.wait_for(
            "reaction_add",
            check=lambda r, u: u == ctx.author
            and r.message.id == confirm.id
            and str(r.emoji) in ("\N{WHITE HEAVY CHECK MARK}", "\N{CROSS MARK}"),
        )

        if str(is_confirmed[0].emoji) == "\N{CROSS MARK}":
            await ctx.send("Aborting")
            return
        msg = await ctx.original_response()
        await msg.clear_reactions()
        await ctx.edit_original_response(content="Syncing the book list channel...")
        await self._setup_book_list_channel(channel)
        await ctx.edit_original_response(content="Done syncing the book list channel")

    @maintenance.sub_command(
        description="Cleans up non bot messages in the book list channel"
    )
    @commands.guild_only()
    @commands.has_permissions(manage_messages=True, manage_channels=True)
    async def cleanup_book_list_channel(
        self, ctx: disnake.ApplicationCommandInteraction
    ):
        guild_config = self.get_guild_config(ctx.guild)
        if not guild_config.book_list_channel:
            await ctx.send("Book list channel is not set", ephemeral=True)
            return
        channel = ctx.guild.get_channel(guild_config.book_list_channel)
        if not channel:
            await ctx.send("Book list channel is not found", ephemeral=True)
            return
        await ctx.send(
            "Are you sure you want to clean up the book list channel? "
            "This will delete all the messages in the book list channel that are not "
            "posted by the bot."
        )
        # TODO: Extract this confirmation logic into a separate function
        confirm = await ctx.original_response()
        await confirm.add_reaction("\N{WHITE HEAVY CHECK MARK}")
        await confirm.add_reaction("\N{CROSS MARK}")

        is_confirmed = await self.bot.wait_for(
            "reaction_add",
            check=lambda r, u: u == ctx.author
            and r.message.id == confirm.id
            and str(r.emoji) in ("\N{WHITE HEAVY CHECK MARK}", "\N{CROSS MARK}"),
        )

        if str(is_confirmed[0].emoji) == "\N{CROSS MARK}":
            await ctx.send("Aborting")
            return
        msg = await ctx.original_response()
        await msg.clear_reactions()
        await ctx.edit_original_response(content="Cleaning up the book list channel...")
        await self._cleanup_book_list_channel(channel)
        await ctx.edit_original_response(
            content="Done cleaning up the book list channel"
        )

    @cmd_book_list.sub_command()
    async def search(self, ctx: disnake.ApplicationCommandInteraction, *, query: str):
        """
        Search for a book in the book list.

        Parameters
        ----------
        query: str
            The query to search for.
        """

        await ctx.send(f"Searching for {query}...")
        books = await search_book_in_db(query, self.bot.engine)
        if not books:
            await ctx.send("No books found")
            return

        await ctx.edit_original_response(content=f"Found {len(books)} books")
        # TODO: Paginate
        for book in books:
            # TODO: Extract to function
            embed = disnake.Embed(title=book.title)
            embed.add_field(name="Author", value=book.author, inline=False)
            embed.add_field(name="ISBN", value=book.isbn, inline=False)
            embed.add_field(name="Subject", value=book.subject, inline=False)
            embed.add_field(name="S3 Key", value=book.s3_key, inline=False)
            await ctx.send(embed=embed)

    @cmd_book_list.sub_command()
    async def get_upload_link(self, ctx: disnake.ApplicationCommandInteraction):
        """
        Get a link to upload your book to the books list.
        """
        # TODO: Implement this
        await ctx.send("This feature has yet to be implemented")

    @commands.command(name="upload_book_file")
    async def file_upload(self, ctx: commands.Context):
        """
        Uploads a book file to the book list.
        """
        if not ctx.message.attachments:
            wait_timeout = 60

            timestamp = f"<t:{int((datetime.utcnow() + timedelta(seconds=wait_timeout)).timestamp())}:T>"

            orig_msg = await ctx.send(
                f"Please upload your book file before {timestamp}"
            )

            message = await self.bot.wait_for(
                "message",
                check=lambda m: m.author == ctx.author and m.channel == ctx.channel,
                timeout=wait_timeout,
            )
            if not message.attachments:
                await orig_msg.edit("No file attached. Aborting")
                return
            if len(message.attachments) > 1:
                await orig_msg.edit(
                    "More than one file attached. Please only attach one file."
                )
                return
        else:
            message = ctx.message
        book_file: disnake.Attachment = message.attachments[0]
        msg = await ctx.send("Processing")
        if not book_file.filename.endswith(".pdf"):
            await msg.edit("Only PDF files are allowed.")
            return
        await ctx.send(
            f"Configure your upload of {message.attachments[0].url}",
            view=UploadView(message.attachments[0].url, message=msg, bot=self.bot),
        )

    @cmd_book_list.sub_command(description="Uploads your book to the book list.")
    async def upload(
        self,
        ctx: disnake.ApplicationCommandInteraction,
        *,
        url: str = commands.Param(description="The EXACT DOWNLOAD url of your book"),
    ):
        """
        Uploads your book to the book list.
        """
        # TODO: We should try to download the file here to check if it's valid
        await ctx.send("Processing...")
        view = UploadView(url, message=await ctx.original_response(), bot=self.bot)
        await view.message.edit(f"Configure your upload of {url}", view=view)

    @cmd_book_list.sub_command(description="Download the book from the database")
    async def download_book(
        self,
        ctx: disnake.ApplicationCommandInteraction,
        *,
        isbn: str = commands.Param(description="The ISBN of the book to download"),
    ):
        """
        Download the book from the database
        """
        # TODO: This will fail if the book is larger than 8MB (Discord's limit)
        async with AsyncSession(self.bot.engine) as sess:
            stmt = select(BookInDb).where(BookInDb.isbn == isbn)
            result = await sess.scalars(stmt)
            books = result.fetchall()
            if not books:
                await ctx.send("No book found with that ISBN")
                return
            if len(books) > 1:
                # TODO: This should not happen
                await ctx.send("More than one book found with that ISBN")
                return
            book: BookInDb = books[0]
            await ctx.send(f"Downloading {book.title}...")
            book_file = await download_book_from_db(book.s3_key, self.bot.boto3_sess)
            if book_file is None:
                await ctx.send("Failed to download book")
                return
            bio = BytesIO()
            bio.write(book_file)
            bio.seek(0)

            # TODO: Filename should be sanitized. Actually, we should do that
            #  before uploading the book
            await ctx.send(
                f"Your file {book.title} by {book.author} is ready",
                file=disnake.File(bio, filename=book.title + ".pdf"),
            )

    async def _setup_book_list_channel(self, channel: disnake.TextChannel):
        """
        Sets up the book list channel
        """
        self.logger.info(
            "Setting up book list channel %s in server %s", channel, channel.guild
        )
        await channel.purge()
        info_msg = await channel.send("**Books List Channel**")
        await info_msg.pin(reason="Info message for books list channel")
        self.logger.info("Book list channel setup complete")

    async def _cleanup_book_list_channel(self, channel: disnake.TextChannel):
        """
        Cleans up the book list channel
        """
        self.logger.info(
            "Cleaning up book list channel %s in server %s", channel, channel.guild
        )
        # get all messages not sent by the bot, and before 14 days of age
        messages = await channel.history(limit=100).flatten()
        messages = list(filter(lambda m: m.author != self.bot.user, messages))
        if len(messages) == 100:
            # The channel is too messed up, recommend a resync
            # TODO: Raise
            return

        await channel.delete_messages(messages)
        self.logger.info("Book list channel cleanup complete")


def setup(bot: BookBot):
    bot.add_cog(BookListPlugin(bot))
